import streamlit as st
import pandas as pd
import itertools
import random
from collections import Counter
import re
import json
import os
import datetime

# ===========================================================
# 1. ì´ˆê¸° ì„¤ì • ë° ë°ì´í„° ê´€ë¦¬
# ===========================================================

st.set_page_config(page_title="ë…ì„œëª¨ì„ ì¡° í¸ì„± ì‹œìŠ¤í…œ", page_icon="ğŸ“š", layout="wide")

DB_FILE = "meeting_db.json"

# ì´ë¦„ í†µì¼ ë§¤í•‘ (ìˆ˜ì •ì´ë‚˜ ì¶”ê°€ê°€ í•„ìš”í•˜ë©´ ì—¬ê¸°ì„œ ê´€ë¦¬)
NAME_MAP = {
    "í˜œì€": "ë‹´ì´", "ë…¸ì¥¬": "ë…¸ì£¼", "ì§€ë¯¼": "ì´ì§€ë¯¼", "ì§€ë¯¼(í•œ)": "í•œì§€ë¯¼",
    "ì •ì„ì˜": "ì„ì˜", "ìœ¤ìŠ¹í˜„": "ìŠ¹í˜„", "ì •ì¼ê·¼": "ì¼ê·¼"
}

def clean_name(name):
    # ê´„í˜¸ ì œê±° ë° ê³µë°± ì œê±°
    name = re.sub(r'\([^)]*\)', '', name).strip()
    return NAME_MAP.get(name, name)

# --- ì´ˆê¸° ë°ì´í„° (1íšŒ~26íšŒ) ---
DEFAULT_DATA = [
    {"round": 1, "date": "23.10", "groups": [["í˜œì€", "ì •ì€", "ì„êµ¬", "ì¬ì„±", "ì†Œí¬", "ê¸°ì°½", "ì±„ë‹ˆ", "ì„ì •", "ìŠ¹í˜„"]]},
    {"round": 2, "date": "23.11", "groups": [["ì±„ë‹ˆ", "ì‚¬ë‘", "ì€í•˜", "ê¸°ì°½", "ìŠ¹í˜„"]]},
    {"round": 3, "date": "23.12", "groups": [["ì„ì˜", "ê¸°ì°½", "ìŠ¹í˜„", "ì¼ê·¼", "ì •ì€", "ì±„ë‹ˆ", "ì‚¬ë‘"]]},
    {"round": 4, "date": "24.01", "groups": [["ì„ì˜", "íƒœí™˜", "ê¸°ì°½", "ì€í•˜", "ì†Œë‹´", "ìŠ¹í˜„", "ì›ë¹ˆ", "ì€ì²œ", "ì¼ê·¼", "ì„ì •", "ì •ì€", "ì±„ë‹ˆ"]]},
    {"round": 5, "date": "24.02", "groups": [["ì„ì˜", "íƒœí™˜", "ê¸°ì°½", "ë¬´ê·¼", "ì •ì€", "í˜œì€", "ì±„ë‹ˆ"]]},
    {"round": 6, "date": "24.03", "groups": [["ì„ì˜", "íƒœí™˜", "ì€í•˜", "ì„ í¬", "ì›ë¹ˆ", "ì˜ëª¨", "ìŠ¹í˜„", "ì¼ê·¼", "ì‚¬ë‘", "ë¯¸ì£¼", "ì€ì²œ"]]},
    {"round": 7, "date": "24.04", "groups": [["ì„ì˜", "íƒœí™˜", "ì˜ê±´", "ì‚¬ë‘", "ì§„ì•„", "ì •ì€"], ["ìŠ¹í˜„", "ì„ì •", "ì±„ë‹ˆ", "ë¬´ê·¼"], ["ì¼ê·¼", "ì˜ëª¨", "ì€í•˜", "í•˜ëŠ˜", "ë¬¸í˜•", "ì†Œë‹´"]]},
    {"round": 8, "date": "24.05", "groups": [["ê¸°ì°½", "íƒœí™˜", "ìˆ˜ë¹ˆ", "ì€í•˜", "ì •ì€"], ["ì±„ë‹ˆ", "ìŠ¹í˜„", "ì„ í¬", "ì‚¬ë‘", "ì„ì˜"]]},
    {"round": 9, "date": "24.06", "groups": [["ê¸°ì°½", "ì„ í¬", "ì‚¬ë‘", "ë¬¸í˜•", "ì„±ìš´", "ìˆ˜ë¯¼"], ["ì •ì€", "ì„ì˜", "ì˜ëª¨", "ìˆ˜ë¹ˆ", "ë¬´ê·¼", "ë„ì•„"], ["ì±„ë‹ˆ", "íƒœí™˜", "í˜œì€", "ì€í•˜", "ì€ì²œ"]]},
    {"round": 10, "date": "24.07", "groups": [["ê¸°ì°½", "ì•„ë¡ ", "ì„±ì€", "ì€í•˜", "ì‚¬ë‘", "ì§„ì•„"], ["ì •ì€", "ì±„ì•„", "ë¬¸í˜•", "ìˆ˜ë¹ˆ", "íƒœí™˜", "ìˆ˜ë¯¼"], ["ì±„ë‹ˆ", "ì„ì˜", "ë…¸ì£¼", "ë¬´ê·¼", "í˜œì€", "ì€ì²œ"]]},
    {"round": 11, "date": "24.08", "groups": [["ê¸°ì°½", "ì¤€ì˜¤", "ìˆ˜ë¹ˆ", "ë¯¼ì„ ", "ë™ê·¼", "ì§„ì•„", "ì„ í¬"], ["ì˜ëª¨", "ë…¸ì¥¬", "ìˆ˜ë¯¼", "ì•„ë¡ ", "ì„ì˜", "ì±„ì•„"]]},
    {"round": 12, "date": "24.09", "groups": [["íƒœí™˜", "ì„ì˜", "ì¤€ì˜¤", "ì€í•˜", "ì±„ë‹ˆ", "ì„±ì€"], ["ê¸°ì°½", "ê´‘í˜„", "ë…¸ì£¼", "ë¯¼ì„ ", "ë™ê·¼", "í˜œì€", "ì˜ëª¨"], ["ë¬´ê·¼", "ì•„ë¡ ", "ì±„ì•„", "ìˆ˜ë¯¼", "ìŠ¹í˜„", "ì •ì€"]]},
    {"round": 13, "date": "24.10", "groups": [["ê¸°ì°½", "í˜¸í˜•", "íƒœí™˜", "í˜œì€", "ì„ í¬", "ì€í•˜", "ì„±ì€"], ["ë¬´ê·¼", "ì„¸ì—˜", "ì„ì˜", "ë¯¼ì„ ", "í•˜ì˜"], ["ì±„ë‹ˆ", "ë¬¸í˜•", "ì˜ëª¨", "ì±„ì•„", "ìˆ˜ë¯¼"], ["ì •ì€", "ê´‘í˜„", "ë™ê·¼", "ìŠ¹í˜„", "ìˆ˜ë¹ˆ", "ë…¸ì£¼"]]},
    {"round": 14, "date": "24.11", "groups": [["ì±„ë‹ˆ", "ì±„ì•„", "ì§„ì•„", "ì€ì²œ", "ë™ê·¼", "ì„êµ¬", "ì•„ë¡ "], ["ê¸°ì°½", "ì„±ì€", "í‚´í‚´", "ì§€ì™„", "ê±´í˜¸", "í˜„ì˜", "ë ˆì´ë‚˜", "ë„í¬", "ì§€ì—°"], ["ì˜ëª¨", "íƒœí™˜", "ë¯¸ì£¼", "ë¯¼ì„ ", "í˜¸í˜•", "ì›ë¹ˆ", "ê´‘í˜„"], ["í˜œì€", "ë¬´ê·¼", "ì€í•˜", "ë¬¸í˜•", "ì¤€ì˜¤", "ëŒ€ê³¤", "ì„ì˜"]]},
    {"round": 15, "date": "24.12", "groups": [["íƒœí™˜", "ìˆ˜ë¯¼", "ì€ì²œ", "ë…¸ì¥¬", "ì„±ì€", "ë¯¸ì£¼"], ["ë¬´ê·¼", "ë¯¸ì£¼", "ëŒ€ê³¤", "í‚´í‚´", "ë™ê·¼", "ì±„ì•„"], ["ê¸°ì°½", "ì •ì€", "íƒœì„ ", "ì„œí¬", "íƒœë¦¬", "ë¯¼ê·œ", "ì„ì˜"], ["ì±„ë‹ˆ", "í˜œì€", "ì€í•˜", "í˜¸í˜•", "ì§€ì™„", "ì¤€ì˜¤", "ë„í¬"]]},
    {"round": 16, "date": "25.01", "groups": [["ê¸°ì°½", "íƒœì„ ", "ë¬¸í˜•", "í•˜ì˜", "ì„ í¬", "ë…¸ì£¼", "ì„ì˜"], ["ë¬´ê·¼", "í˜¸í˜•", "ì•„ë¡ ", "ì„±ì€", "íƒœë¦¬", "ë„í¬"], ["ì±„ë‹ˆ", "ìŠ¹í˜„", "ê´‘í˜„", "ê±´í˜¸", "ì§€ì—°", "ì€í•˜"], ["ì •ì€", "ì€ì²œ", "ë¯¼ê·œ", "ì¤€ì˜¤", "ë¯¼ì„ ", "ìˆ˜ë¹ˆ", "ë‹´ì´"]]},
    {"round": 17, "date": "25.02", "groups": [["íƒœí™˜", "ê¸°ì°½", "ì¤€ì˜¤", "ëŒ€ê³¤", "ì€í•˜", "ì±„ë‹ˆ"], ["ì˜ëª¨", "ì„ì˜", "ë¯¼ê·œ", "ê´‘í˜„", "íƒœë¦¬", "ë‹´ì´"], ["ë¬´ê·¼", "ê±´í˜¸", "ì•„ë¡ ", "ì€ì²œ", "ì„ í¬", "ë¯¼ì„ "]]},
    {"round": 18, "date": "25.03", "groups": [["íƒœí™˜", "ì¤€ì˜¤", "ê´‘í˜„", "ë‹´í¬", "ë…¸ì¥¬", "íƒœë¦¬"], ["ì±„ë‹ˆ", "ì•„ë¡ ", "ê¸°ì°½", "ì„ì˜", "ì€í•˜", "ë¯¼ì„ ", "ì„ í¬"], ["ë‹´ì´", "ëŒ€ê³¤", "ê±´í˜¸", "í˜¸í˜•", "ì§€ë¯¼", "ì±„ì•„"]]},
    {"round": 19, "date": "25.04", "groups": [["ì•„ë¡ ", "ë¬´ê·¼", "ì„±ì€", "í‚´í‚´", "ë„í¬"], ["ì¤€ì˜¤", "ì±„ë‹ˆ", "ì„ì˜", "ë‹´í¬", "íƒœë¦¬"], ["ë¯¼ì„ ", "íƒœí™˜", "ì±„ì•„", "ê´‘í˜„", "ì§€ë¯¼"], ["ë‹´ì´", "ê±´í˜¸", "ê¸°ì°½", "ë™ê·¼", "ë…¸ì£¼"]]},
    {"round": 20, "date": "25.05", "groups": [["ê¸°ì°½", "íƒœë¦¬", "ë™ìš±", "ì§€ì—°", "ì±„ë‹ˆ", "ê¹€ë¯¼", "ì •ì—°"], ["íƒœí™˜", "ìŠ¹í˜„", "í˜¸í˜•", "ìˆ˜ë¯¼", "ë…¸ì¥¬", "ê·œì°¬", "ë¯¼ìŠ¹2"], ["ë¬´ê·¼", "ì„ì˜", "íƒœì„ ", "ì„±ì€", "ì±„ì•„", "ì€í•˜", "ì€ì²œ"], ["ë‹´ì´", "ì¤€ì˜¤", "ê´‘í˜„", "í‚´í‚´", "ì„ í¬", "ë¯¼ìŠ¹", "ë‹´í¬"]]},
    {"round": 21, "date": "25.06", "groups": [["ì±„ë‹ˆ", "ê·œì°¬", "ì•„ë¡ ", "ì˜ëª¨", "íƒœì„ ", "ë¯¼ì„ ", "ë…¸ì£¼"], ["ë‹´ì´", "ìŠ¹í˜„", "ì°¬ìˆ˜", "ë™ê·¼", "ì¤€ì˜¤", "ì„±ì€", "ì±„ì•„"], ["íƒœí™˜", "ê±´í˜¸", "ê¸°ì°½", "í˜¸í˜•", "ë™ê·¼", "íƒœë¦¬", "ì§€ë¯¼"], ["ë¬´ê·¼", "ì„¸ì—˜", "ë¬¸í˜•", "ê´‘í˜„", "í•˜ëŠ˜", "ìˆ˜ë¯¼", "í‚´í‚´"]]},
    {"round": 22, "date": "25.07", "groups": [["ìˆ˜ë¯¼", "ë¯¼ì„ ", "ê´‘í˜„", "ì¤€ì˜¤", "ì´ì§€ë¯¼", "íƒœë¦¬"], ["ë‹´ì´", "ì„±ì€", "ê¸°ì°½", "íƒœì„ ", "ì˜í™˜", "í•œì§€ë¯¼"], ["ì±„ë‹ˆ", "ë…¸ì£¼", "í•˜ë¦¬", "ê·œì°¬", "ë™ìš±", "ë¯¼ìŠ¹", "ëŒ€ê³¤"], ["ì€í•˜", "ì„ í¬", "ë‹´í¬", "ê±´í˜¸", "ë¬´ê·¼", "ì°¬ìˆ˜", "ìœ¤ìƒ"]]},
    {"round": 23, "date": "25.08", "groups": [["ë‹´ì´", "ê¸°ì°½", "ë™ìš±", "ì°¬ìˆ˜", "ì±„ì•„"], ["ì±„ë‹ˆ", "ì€ì²œ", "ë™ê·¼", "ë¯¼ìŠ¹", "ìˆ˜ë¯¼"], ["ë¬´ê·¼", "íƒœì„ ", "í•˜ë¦¬", "ì„ì˜"], ["íƒœí™˜", "ì£¼ì˜", "ì˜ëª¨", "ë¯¼ì„ ", "ê·œì°¬"], ["ê±´í˜¸", "íƒœë¦¬", "ë‹´í¬"]]},
    {"round": 24, "date": "25.09", "groups": [["íƒœí™˜", "ê·œì°¬", "ë™ìš±", "ì§€ë¯¼(í•œ)", "ë¯¼ì„ "], ["ì±„ë‹ˆ", "ìŠ¹í˜„", "íƒœì„ ", "ì¤€ì˜¤", "ì€í•˜", "ì±„ì•„"], ["ê¸°ì°½", "ëŒ€ê³¤", "ì°¬ìˆ˜", "ê´‘í˜„", "ë…¸ì£¼", "ë‹´í¬"], ["ë¬´ê·¼", "ê±´í˜¸", "ì„ì˜", "ìœ¤ì„œ", "íƒœë¦¬", "í•˜ë¦¬"]]},
    {"round": 25, "date": "25.10", "groups": [["ì±„ë‹ˆ", "ì˜ëª¨", "ë™ê·¼", "ë‹´í¬", "ìˆ˜ë¯¼", "ê´‘í˜„"], ["ë‹´ì´", "íƒœì„ ", "ì¬ì›", "ì±„ì•„", "ë¯¼ì„ ", "ì„ì˜"], ["íƒœí™˜", "í˜¸í˜•", "ì•„ë¡ ", "ë¯¼ìŠ¹", "ì€í•˜", "íƒœë¦¬"], ["ê¸°ì°½", "ë™ìš±", "ë¬´ê·¼", "ìœ¤ì„œ", "ë…¸ì¥¬", "ìŠ¹í˜„"]]},
    {"round": 26, "date": "25.11", "groups": [["ê·œì°¬", "ëŒ€ê³¤", "ì±„ì•„", "ì„ í¬", "ê¸°ì°½"], ["ì±„ë‹ˆ", "ë…¸ì£¼", "ë™ê·¼", "ì€í•˜", "ì€ì²œ"], ["ë‹´ì´", "ë¯¼ìŠ¹", "ì°¬ìˆ˜", "ì„±ì€", "í•˜ë¦¬"], ["ìˆ˜ë¯¼", "ë¬´ê·¼", "ìœ¤ì„œ", "ë¯¼ì„ ", "ì¤€ì˜¤", "ì„ì˜"]]},
]

def load_data():
    if os.path.exists(DB_FILE):
        try:
            with open(DB_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return DEFAULT_DATA
    return DEFAULT_DATA

def save_data(data):
    with open(DB_FILE, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=4)

def analyze_overlap(data_list):
    counter = Counter()
    all_people = set()
    
    for record in data_list:
        for group in record["groups"]:
            # ì •ì œëœ ì´ë¦„ ë¦¬ìŠ¤íŠ¸ ìƒì„±
            cleaned_group = [clean_name(m) for m in group if clean_name(m)]
            cleaned_group = list(set(cleaned_group))
            all_people.update(cleaned_group)
            
            # ë§Œë‚¨ íšŸìˆ˜ ê¸°ë¡
            for m1, m2 in itertools.combinations(cleaned_group, 2):
                pair = tuple(sorted([m1, m2]))
                counter[pair] += 1
    return counter, sorted(list(all_people))

# ë°ì´í„° ë¡œë“œ
db_data = load_data()
overlap_counts, all_members = analyze_overlap(db_data)

# ===========================================================
# 2. UI êµ¬í˜„ (íƒ­ êµ¬ì¡°)
# ===========================================================
st.title("ğŸ“š ë…ì„œëª¨ì„ ìš´ì˜ ì‹œìŠ¤í…œ")

# íƒ­ ë¶„ë¦¬
tab1, tab2 = st.tabs(["ğŸ› ï¸ ì¡° í¸ì„± (Generator)", "ğŸ“ íˆìŠ¤í† ë¦¬ ê´€ë¦¬ (Admin)"])

# ---------------------------------------------------
# [íƒ­ 1] ì¡° í¸ì„± ê¸°ëŠ¥
# ---------------------------------------------------
with tab1:
    st.header("ìƒˆë¡œìš´ ì¡° ë§Œë“¤ê¸°")
    st.caption("ì—­ëŒ€ ë°ì´í„°ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê²¹ì¹˜ì§€ ì•Šê²Œ ìë™ìœ¼ë¡œ í¸ì„±í•©ë‹ˆë‹¤.")
    
    col1, col2 = st.columns([1, 2])
    with col1:
        st.subheader("ì„¤ì •")
        # ëª…ë‹¨ ì…ë ¥
        input_type = st.radio("ëª…ë‹¨ ì…ë ¥ ë°©ì‹", ["ì§ì ‘ ì…ë ¥", "ì „ì²´ ëª…ë‹¨ì—ì„œ ì„ íƒ"], horizontal=True)
        current_attendees = []
        
        if input_type == "ì§ì ‘ ì…ë ¥":
            raw = st.text_area("ì°¸ì„ì (ì½¤ë§ˆ/ì—”í„°ë¡œ êµ¬ë¶„)", height=150, placeholder="ê¸°ì°½, ì±„ë‹ˆ, ë¬´ê·¼...")
            if raw:
                current_attendees = [n.strip() for n in re.split(r'[,\n\t]+', raw) if n.strip()]
        else:
            current_attendees = st.multiselect("ì°¸ì„ì ì„ íƒ", all_members)
        
        st.info(f"ì°¸ì„ ì¸ì›: **{len(current_attendees)}ëª…**")

        # ì¡°ì¥ ì„ íƒ
        current_leaders = []
        if current_attendees:
            current_leaders = st.multiselect("ì¡°ì¥ ì„ íƒ", current_attendees)
            
        run_btn = st.button("ğŸš€ ì¡° í¸ì„± ì‹¤í–‰", type="primary")

    with col2:
        if run_btn:
            if not current_leaders:
                st.error("ì¡°ì¥ì„ ì„ íƒí•´ì£¼ì„¸ìš”.")
            elif len(current_leaders) > len(current_attendees):
                st.error("ì¡°ì¥ì´ ì°¸ì„ìë³´ë‹¤ ë§ìŠµë‹ˆë‹¤.")
            else:
                # --- ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰ ---
                teams = {leader: [leader] for leader in current_leaders}
                pool = [p for p in current_attendees if clean_name(p) not in [clean_name(l) for l in current_leaders]]
                random.shuffle(pool)
                
                for person in pool:
                    p_name = clean_name(person)
                    best_leader = None
                    min_score = float('inf')
                    sorted_leaders = sorted(teams.keys(), key=lambda k: len(teams[k])) # ì¸ì› ì ì€ ì¡° ìš°ì„ 
                    
                    for leader in sorted_leaders:
                        current_team = teams[leader]
                        score = 0
                        for member in current_team:
                            pair = tuple(sorted([p_name, clean_name(member)]))
                            score += overlap_counts[pair]
                        if score < min_score:
                            min_score = score
                            best_leader = leader
                    teams[best_leader].append(person)
                
                # --- ê²°ê³¼ í‘œì‹œ ---
                st.subheader("ğŸ‰ í¸ì„± ê²°ê³¼")
                
                # ê²°ê³¼ í‘œì‹œìš© ì»¨í…Œì´ë„ˆ
                result_cols = st.columns(len(teams))
                for idx, (leader, members) in enumerate(teams.items()):
                    with result_cols[idx % len(result_cols)]:
                        with st.container(border=True):
                            st.markdown(f"**{idx+1}ì¡° ({len(members)}ëª…)**")
                            st.markdown(f"ğŸ‘‘ **{leader}**")
                            for m in members:
                                if m != leader:
                                    st.text(f"- {m}")
                            
                            # ê²€ì¦
                            warnings = []
                            for m1, m2 in itertools.combinations(members, 2):
                                if overlap_counts[tuple(sorted([clean_name(m1), clean_name(m2)]))] >= 3:
                                    warnings.append(f"{m1}-{m2}")
                            if warnings:
                                st.warning(f"âš ï¸ {', '.join(warnings)}")
                            else:
                                st.success("OK")
                
                # --- ì €ì¥ ê¸°ëŠ¥ ---
                st.divider()
                st.write("ì´ ê²°ê³¼ê°€ ë§ˆìŒì— ë“œì‹œë©´ ì €ì¥í•˜ì„¸ìš”.")
                if st.button("ğŸ’¾ ê²°ê³¼ ì €ì¥í•˜ê¸° (DB ì—…ë°ì´íŠ¸)"):
                    new_record = {
                        "round": len(db_data) + 1,
                        "date": datetime.datetime.now().strftime("%y.%m"),
                        "groups": list(teams.values())
                    }
                    db_data.append(new_record)
                    save_data(db_data)
                    st.success(f"{new_record['round']}íšŒì°¨ ë°ì´í„°ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! (íˆìŠ¤í† ë¦¬ íƒ­ì—ì„œ í™•ì¸ ê°€ëŠ¥)")
                    st.rerun()

# ---------------------------------------------------
# [íƒ­ 2] íˆìŠ¤í† ë¦¬ ê´€ë¦¬ ê¸°ëŠ¥ (ìˆ˜ì •/ì‚­ì œ)
# ---------------------------------------------------
with tab2:
    st.header("ğŸ“ íˆìŠ¤í† ë¦¬ ë°ì´í„° ê´€ë¦¬")
    st.caption("ì˜ëª» ì…ë ¥ëœ ë°ì´í„°ë¥¼ ìˆ˜ì •í•˜ê±°ë‚˜ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")

    # ë°ì´í„°ë¥¼ DataFrameìœ¼ë¡œ ë³€í™˜í•˜ì—¬ í‘œì‹œ
    # ìˆ˜ì •í•˜ê¸° ì‰½ë„ë¡ í¬ë§·íŒ…: íšŒì°¨ | ë‚ ì§œ | ì¡°ì¥ | ì¡°ì›ë“¤(í…ìŠ¤íŠ¸)
    
    flat_data = []
    for record in db_data:
        groups_str = []
        for group in record['groups']:
            groups_str.append(f"[{group[0]}(ì¥): {', '.join(group[1:])}]")
        
        flat_data.append({
            "íšŒì°¨": record['round'],
            "ì‹œê¸°": record['date'],
            "ì¡° í¸ì„± ë‚´ì—­": " / ".join(groups_str)
        })
    
    df = pd.DataFrame(flat_data)
    
    # 1. ë°ì´í„° ì¡°íšŒ (í¸ì§‘ ê°€ëŠ¥í•œ í…Œì´ë¸”)
    st.subheader("1. ë°ì´í„° ì¡°íšŒ ë° ìˆ˜ì •")
    st.info("ì•„ë˜ í‘œëŠ” ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤. ìˆ˜ì •ì„ ì›í•˜ì‹œë©´ í•˜ë‹¨ì˜ 'ì‚­ì œ' í›„ 'ì¬ë“±ë¡' ê¸°ëŠ¥ì„ ì´ìš©í•˜ê±°ë‚˜ ì½”ë“œë¥¼ ê³ ë„í™”í•´ì•¼ í•©ë‹ˆë‹¤.")
    st.dataframe(df, use_container_width=True, hide_index=True)
    
    st.divider()
    
    # 2. íŠ¹ì • íšŒì°¨ ì‚­ì œ ê¸°ëŠ¥
    st.subheader("2. ì˜ëª»ëœ íšŒì°¨ ì‚­ì œ")
    
    col_del1, col_del2 = st.columns([3, 1])
    with col_del1:
        delete_target = st.selectbox("ì‚­ì œí•  íšŒì°¨ ì„ íƒ", df['íšŒì°¨'].sort_values(ascending=False))
    with col_del2:
        st.write("") # ê°„ê²© ë§ì¶¤
        st.write("")
        if st.button("ğŸ—‘ï¸ í•´ë‹¹ íšŒì°¨ ì‚­ì œ", type="primary"):
            # ë¦¬ìŠ¤íŠ¸ì—ì„œ í•´ë‹¹ íšŒì°¨ ì‚­ì œ
            new_db = [r for r in db_data if r['round'] != delete_target]
            # ë²ˆí˜¸ ì¬ì •ë ¬ (ì„ íƒ ì‚¬í•­)
            # for i, r in enumerate(new_db):
            #     r['round'] = i + 1 
            save_data(new_db)
            st.success(f"{delete_target}íšŒì°¨ ë°ì´í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.")
            st.rerun()

    # 3. ìˆ˜ë™ ë°ì´í„° ì¶”ê°€ (ëˆ„ë½ëœ ê²ƒ ë„£ê¸°)
    st.divider()
    with st.expander("â• ìˆ˜ë™ìœ¼ë¡œ ë°ì´í„° ì¶”ê°€í•˜ê¸° (ê³ ê¸‰)"):
        st.write("ìë™ ì¡° í¸ì„±ì´ ì•„ë‹ˆë¼, ìˆ˜ë™ìœ¼ë¡œ í–ˆë˜ ëª¨ì„ì„ ê¸°ë¡í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•˜ì„¸ìš”.")
        
        new_round_num = st.number_input("íšŒì°¨", value=len(db_data)+1, step=1)
        new_date = st.text_input("ì‹œê¸° (ì˜ˆ: 25.12)", value=datetime.datetime.now().strftime("%y.%m"))
        new_group_text = st.text_area("ì¡° í¸ì„± ë‚´ìš© (í˜•ì‹: [[ì¡°ì¥, ì¡°ì›1, ì¡°ì›2], [ì¡°ì¥2, ì¡°ì›...]])")
        
        if st.button("ìˆ˜ë™ ì¶”ê°€"):
            try:
                parsed_groups = json.loads(new_group_text)
                if isinstance(parsed_groups, list):
                    new_record = {"round": new_round_num, "date": new_date, "groups": parsed_groups}
                    db_data.append(new_record)
                    # íšŒì°¨ìˆœ ì •ë ¬
                    db_data.sort(key=lambda x: x['round'])
                    save_data(db_data)
                    st.success("ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.")
                    st.rerun()
                else:
                    st.error("í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ê´„í˜¸[] ë¦¬ìŠ¤íŠ¸ í˜•ì‹ì´ì–´ì•¼ í•©ë‹ˆë‹¤.")
            except:
                st.error("JSON í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤. (ì˜ˆ: [['ì² ìˆ˜', 'ì˜í¬'], ['ë¯¼ìˆ˜', 'ê¸¸ë™']])")
